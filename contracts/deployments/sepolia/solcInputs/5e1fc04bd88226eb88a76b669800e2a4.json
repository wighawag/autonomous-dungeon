{
  "language": "Solidity",
  "sources": {
    "forge-deploy-proxy/src/ForgeDeploy_Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n\t/// @notice Query if a contract implements an interface\n\t/// @param interfaceID The interface identifier, as specified in ERC-165\n\t/// @dev Interface identification is specified in ERC-165. This function\n\t///  uses less than 30,000 gas.\n\t/// @return `true` if the contract implements `interfaceID` and\n\t///  `interfaceID` is not 0xffffffff, `false` otherwise\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721WithBlocknumber.sol\";\nimport \"./ImplementingERC721Internal.sol\";\n\nimport \"../../openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract BasicERC721 is IERC721, IERC721WithBlocknumber, ImplementingERC721Internal {\n\tusing Openzeppelin_Address for address;\n\n\tbytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\n\tuint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\tmapping(uint256 => uint256) internal _owners;\n\tmapping(address => uint256) internal _balances;\n\tmapping(address => mapping(address => bool)) internal _operatorsForAll;\n\tmapping(uint256 => address) internal _operators;\n\n\t/// @inheritdoc IERC721\n\tfunction approve(address operator, uint256 tokenID) external override {\n\t\t(address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenID);\n\t\t}\n\t\tif (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n\t\t\trevert NotAuthorized();\n\t\t}\n\t\t_approveFor(owner, nonce, operator, tokenID);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID\n\t) external override {\n\t\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenID);\n\t\t}\n\t\tif (from != owner) {\n\t\t\trevert NotOwner(from, owner);\n\t\t}\n\t\tif (to == address(0) || to == address(this)) {\n\t\t\trevert InvalidAddress(to);\n\t\t}\n\t\tif (msg.sender != from) {\n\t\t\tif (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n\t\t\t\trevert NotAuthorized();\n\t\t\t}\n\t\t}\n\t\t_transferFrom(from, to, tokenID, (nonce >> 24) != 0);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID\n\t) external override {\n\t\tsafeTransferFrom(from, to, tokenID, \"\");\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction setApprovalForAll(address operator, bool approved) external override {\n\t\t_setApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction balanceOf(address owner) public view virtual override returns (uint256 balance) {\n\t\tif (owner == address(0)) {\n\t\t\trevert InvalidAddress(owner);\n\t\t}\n\t\tbalance = _balances[owner];\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction ownerOf(uint256 tokenID) external view override returns (address owner) {\n\t\towner = _ownerOf(tokenID);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenID);\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction getApproved(uint256 tokenID) external view override returns (address operator) {\n\t\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenID);\n\t\t}\n\t\tif (operatorEnabled) {\n\t\t\treturn _operators[tokenID];\n\t\t} else {\n\t\t\treturn address(0);\n\t\t}\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\n\t\treturn _operatorsForAll[owner][operator];\n\t}\n\n\t/// @inheritdoc IERC721\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID,\n\t\tbytes memory data\n\t) public override {\n\t\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\n\t\tif (owner == address(0)) {\n\t\t\trevert NonExistentToken(tokenID);\n\t\t}\n\t\tif (owner != from) {\n\t\t\trevert NotOwner(from, owner);\n\t\t}\n\n\t\tif (to == address(0) || to == address(this)) {\n\t\t\trevert InvalidAddress(to);\n\t\t}\n\n\t\tif (msg.sender != from) {\n\t\t\tif (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n\t\t\t\trevert NotAuthorized();\n\t\t\t}\n\t\t}\n\t\t_safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\n\t}\n\n\t/// @inheritdoc IERC165\n\tfunction supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n\t\t/// 0x01ffc9a7 is ERC165.\n\t\t/// 0x80ac58cd is ERC721\n\t\t/// 0x5b5e139f is for ERC721 metadata\n\t\treturn interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\n\t}\n\n\t/// @inheritdoc IERC721WithBlocknumber\n\tfunction ownerAndLastTransferBlockNumberOf(uint256 tokenID)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (address owner, uint256 blockNumber)\n\t{\n\t\t(address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\n\t\towner = currentOwner;\n\t\tblockNumber = (nonce >> 24);\n\t}\n\n\t/// @inheritdoc IERC721WithBlocknumber\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\treturns (OwnerData[] memory ownersData)\n\t{\n\t\townersData = new OwnerData[](tokenIDs.length);\n\t\tfor (uint256 i = 0; i < tokenIDs.length; i++) {\n\t\t\tuint256 data = _owners[tokenIDs[i]];\n\t\t\townersData[i].owner = address(uint160(data));\n\t\t\townersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\n\t\t}\n\t}\n\n\t// ------------------------------------------------------------------------------------------------------------------\n\t// INTERNALS\n\t// ------------------------------------------------------------------------------------------------------------------\n\n\tfunction _safeMint(address to, uint256 tokenID) internal {\n\t\t_safeTransferFrom(address(0), to, tokenID, false, \"\");\n\t}\n\n\tfunction _safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID,\n\t\tbool registered,\n\t\tbytes memory data\n\t) internal {\n\t\t_transferFrom(from, to, tokenID, registered);\n\t\tif (to.isContract()) {\n\t\t\tif (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\n\t\t\t\trevert TransferRejected();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID,\n\t\tbool registered\n\t) internal virtual {\n\t\tunchecked {\n\t\t\t_balances[to]++;\n\t\t\tif (registered) {\n\t\t\t\t_balances[from]--;\n\t\t\t}\n\t\t}\n\n\t\t// We encode the blockNumber in the token nonce. We can then use it for count voting.\n\t\t_owners[tokenID] = (block.number << 184) | uint256(uint160(to));\n\t\temit Transfer(from, to, tokenID);\n\t}\n\n\t/// @dev See approve.\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 nonce,\n\t\taddress operator,\n\t\tuint256 tokenID\n\t) internal override {\n\t\tuint256 blockNumber = nonce >> 24;\n\t\tuint256 newNonce = nonce + 1;\n\t\tif (newNonce >> 24 != blockNumber) {\n\t\t\trevert NonceOverflow();\n\t\t}\n\t\tif (operator == address(0)) {\n\t\t\t_owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\n\t\t} else {\n\t\t\t_owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\n\t\t\t_operators[tokenID] = operator;\n\t\t}\n\t\temit Approval(owner, operator, tokenID);\n\t}\n\n\t/// @dev See setApprovalForAll.\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal override {\n\t\t_operatorsForAll[sender][operator] = approved;\n\n\t\temit ApprovalForAll(sender, operator, approved);\n\t}\n\n\t/// @dev Check if receiving contract accepts erc721 transfers.\n\t/// @param operator The address of the operator.\n\t/// @param from The from address, may be different from msg.sender.\n\t/// @param to The adddress we want to transfer to.\n\t/// @param tokenID The id of the token we would like to transfer.\n\t/// @param data Any additional data to send with the transfer.\n\t/// @return Whether the expected value of 0x150b7a02 is returned.\n\tfunction _checkOnERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID,\n\t\tbytes memory data\n\t) internal returns (bool) {\n\t\tbytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\n\t\treturn (retval == ERC721_RECEIVED);\n\t}\n\n\t/// @dev Get the owner of a token.\n\t/// @param tokenID The token to query.\n\tfunction _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\n\t\treturn address(uint160(_owners[tokenID]));\n\t}\n\n\t/// @dev Get the owner and operatorEnabled status of a token.\n\t/// @param tokenID The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return operatorEnabled Whether or not operators are enabled for this token.\n\tfunction _ownerAndOperatorEnabledOf(uint256 tokenID)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (address owner, bool operatorEnabled)\n\t{\n\t\tuint256 data = _owners[tokenID];\n\t\towner = address(uint160(data));\n\t\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n\t}\n\n\t/// @dev Get the owner and the permit nonce of a token.\n\t/// @param tokenID The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n\tfunction _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\n\t\tuint256 data = _owners[tokenID];\n\t\towner = address(uint160(data));\n\t\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n\n\t// @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\n\t/// @param tokenID The token to query.\n\t/// @return owner The owner of the token.\n\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n\t/// @return operatorEnabled Whether or not operators are enabled for this token.\n\tfunction _ownerNonceAndOperatorEnabledOf(uint256 tokenID)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (\n\t\t\taddress owner,\n\t\t\tuint256 nonce,\n\t\t\tbool operatorEnabled\n\t\t)\n\t{\n\t\tuint256 data = _owners[tokenID];\n\t\towner = address(uint160(data));\n\t\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n\t\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/implementations/ImplementingERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ImplementingERC721Internal {\n\tfunction _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\n\n\tfunction _approveFor(\n\t\taddress owner,\n\t\tuint256 nonce,\n\t\taddress operator,\n\t\tuint256 tokenID\n\t) internal virtual;\n\n\tfunction _setApprovalForAll(\n\t\taddress sender,\n\t\taddress operator,\n\t\tbool approved\n\t) internal virtual;\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../ERC165/interfaces/IERC165.sol\";\nimport \"../../utils/GenericErrors.sol\";\n\ninterface IERC721Supply {\n\t/// @notice return the total number of token in existence\n\tfunction totalSupply() external view returns (uint256);\n}\n\ninterface IERC721 is IERC165 {\n\t/// @notice Triggered when a token is transferred\n\t/// @param from the account the token is sent from\n\t/// @param to the account the token is sent to\n\t/// @param tokenID id of the token being sent\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\n\n\t/// @notice Triggered when a token is approved to be sent by another account\n\t///  Note tat the approval get reset when a Transfer event for that same token is emitted.\n\t/// @param owner current owner of the token\n\t/// @param approved account who can know transfer on the owner's behalf\n\t/// @param tokenID id of the token being approved\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\n\n\t/// @notice Triggered when an account approve or disaprove another to transfer on its behalf\n\t/// @param owner the account granting rights over all of its token\n\t/// @param operator account who can know transfer on the owner's behalf\n\t/// @param approved whether it is approved or not\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\t/// @notice The token does not exist\n\t/// @param tokenID id of the expected token\n\terror NonExistentToken(uint256 tokenID);\n\t/// @notice The address from which the token is sent is not the current owner\n\t/// @param provided the address expected to be the current owner\n\t/// @param currentOwner the current owner\n\terror NotOwner(address provided, address currentOwner);\n\t/// @notice An invalid address is specified (for example: zero address)\n\t/// @param addr invalid address\n\terror InvalidAddress(address addr);\n\t/// @notice The Transfer was rejected by the destination\n\terror TransferRejected();\n\t/// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\n\terror NonceOverflow();\n\n\t/// @notice Get the number of tokens owned by an address.\n\t/// @param owner The address to look for.\n\t/// @return balance The number of tokens owned by the address.\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/// @notice Get the owner of a token.\n\t/// @param tokenID The id of the token.\n\t/// @return owner The address of the token owner.\n\tfunction ownerOf(uint256 tokenID) external view returns (address owner);\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenID The id of the token.\n\t/// @param data Additional data.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID,\n\t\tbytes calldata data\n\t) external;\n\n\t/// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n\t/// @param from The send of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenID The id of the token.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID\n\t) external;\n\n\t/// @notice Transfer a token between 2 addresses.\n\t/// @param from The sender of the token.\n\t/// @param to The recipient of the token.\n\t/// @param tokenID The id of the token.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenID\n\t) external;\n\n\t/// @notice Approve an operator to transfer a specific token on the senders behalf.\n\t/// @param operator The address receiving the approval.\n\t/// @param tokenID The id of the token.\n\tfunction approve(address operator, uint256 tokenID) external;\n\n\t/// @notice Set the approval for an operator to manage all the tokens of the sender.\n\t/// @param operator The address receiving the approval.\n\t/// @param approved The determination of the approval.\n\tfunction setApprovalForAll(address operator, bool approved) external;\n\n\t/// @notice Get the approved operator for a specific token.\n\t/// @param tokenID The id of the token.\n\t/// @return operator The address of the operator.\n\tfunction getApproved(uint256 tokenID) external view returns (address operator);\n\n\t/// @notice Check if the sender approved the operator to transfer any of its tokens.\n\t/// @param owner The address of the owner.\n\t/// @param operator The address of the operator.\n\t/// @return isOperator The status of the approval.\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param operator The address which called `safeTransferFrom` function\n\t/// @param from The address which previously owned the token\n\t/// @param tokenID The NFT identifier which is being transferred\n\t/// @param data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenID,\n\t\tbytes calldata data\n\t) external returns (bytes4);\n}\n"
    },
    "solidity-kit/solc_0.8/ERC721/interfaces/IERC721WithBlocknumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721WithBlocknumber {\n\t/// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\n\t/// @param tokenID The id of the token.\n\t/// @return owner The address of the token owner.\n\t/// @return blockNumber The blocknumber at which the last transfer of that id happened.\n\tfunction ownerAndLastTransferBlockNumberOf(uint256 tokenID)\n\t\texternal\n\t\tview\n\t\treturns (address owner, uint256 blockNumber);\n\n\tstruct OwnerData {\n\t\taddress owner;\n\t\tuint256 lastTransferBlockNumber;\n\t}\n\n\t/// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\n\t/// @param tokenIDs The list of token ids to check.\n\t/// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\n\tfunction ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\n\t\texternal\n\t\tview\n\t\treturns (OwnerData[] memory ownersData);\n}\n"
    },
    "solidity-kit/solc_0.8/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Openzeppelin_Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * You shouldn't rely on `isContract` to protect against flash loan attacks!\n\t *\n\t * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n\t * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n\t * constructor.\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// This method relies on extcodesize/address.code.length, which returns 0\n\t\t// for contracts in construction, since the code is only stored at the end\n\t\t// of the constructor execution.\n\n\t\treturn account.code.length > 0;\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t */\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\t/**\n\t * @dev Performs a Solidity function call using a low level `call`. A\n\t * plain `call` is an unsafe replacement for a function call: use this\n\t * function instead.\n\t *\n\t * If `target` reverts with a revert reason, it is bubbled up by this\n\t * function (like regular Solidity function calls).\n\t *\n\t * Returns the raw returned data. To convert to the expected return value,\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\t *\n\t * Requirements:\n\t *\n\t * - `target` must be a contract.\n\t * - calling `target` with `data` must not revert.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but also transferring `value` wei to `target`.\n\t *\n\t * Requirements:\n\t *\n\t * - the calling contract must have an ETH balance of at least `value`.\n\t * - the called Solidity function must be `payable`.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal view returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n\t * revert reason using the provided one.\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction verifyCallResult(\n\t\tbool success,\n\t\tbytes memory returndata,\n\t\tstring memory errorMessage\n\t) internal pure returns (bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\t\t\t\t/// @solidity memory-safe-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "solidity-kit/solc_0.8/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Not authorized to perform this operation\nerror NotAuthorized();\n"
    },
    "src/Characters.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./Vessels.sol\";\n\ncontract Characters is Vessels {\n    function mint(uint256 tokenID, address to) external {\n        // return _safeMint(to, id);\n        return _transferFrom(address(0), to, tokenID, false);\n    }\n}\n"
    },
    "src/Dungeon.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"forge-deploy-proxy/src/ForgeDeploy_Proxied.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\nimport \"./Extraction.sol\";\nimport \"./Characters.sol\";\nimport \"./UsingInternalTimestamp.sol\";\n\ncontract Dungeon is Proxied, UsingInternalTimestamp {\n    // ----------------------------------------------------------------------------------------------\n    // CONSTANTS\n    // ----------------------------------------------------------------------------------------------\n\n    uint256 constant TOTAL = 24 * 3600;\n    uint256 constant ACTION_PERIOD = 23 * 3600;\n    uint256 constant START_TIMESTAMP = 0;\n\n    // ----------------------------------------------------------------------------------------------\n    // EVENTS\n    // ----------------------------------------------------------------------------------------------\n    event CommitmentMade(uint256 indexed characterID, uint32 indexed epoch, bytes24 commitmentHash);\n    event CommitmentVoid(uint256 indexed characterID, uint32 indexed epoch);\n    event CommitmentResolved(\n        uint256 indexed characterID,\n        uint32 indexed epoch,\n        bytes24 indexed commitmentHash,\n        Action[] actions,\n        bytes24 furtherActions\n    );\n\n    event CharacterUpdate(\n        uint256 indexed characterID,\n        uint256 indexed position,\n        uint8 life,\n        uint256 gold,\n        bytes32 equipment,\n        uint16 combatStanceAvailable\n    );\n    event RoomUpdate(uint256 indexed position, bytes32 goldBattle, bytes32 monsterBattle);\n    event EpochHashUpdate(uint256 indexed epoch, bytes32 epochHash);\n    event CharacterEnterTheDungeon(address indexed player, uint256 indexed characterID);\n    event MonsterClaim(uint256 indexed characterID, uint256 indexed position, uint256 indexed epoch);\n    event MonsterDefeat(uint256 indexed position, uint256 indexed epoch);\n\n    // ----------------------------------------------------------------------------------------------\n    // STORAGE TYPES\n    // ----------------------------------------------------------------------------------------------\n\n    struct Character {\n        uint256 position;\n        uint256 gold;\n        // TODO xp\n        uint8 life;\n        bytes32 equipment;\n        uint16 combatStanceAvailable;\n    }\n\n    // struct RoomStatus {\n    //     bytes32 goldBattle; // this represent a battle against other character with gold given to winner\n    //     bytes32 monsterBattle; // this represent a battle against a monster with loot shared (based on success? // or same/similar like goldBattle)\n    // }\n\n    struct GoldBattle {\n        uint256 currentWinner;\n        uint16 combatStance;\n    }\n\n    struct MonsterBattle {\n        uint256 life; // when max uint player have the drop, but it is only given onchain on next epoch reveal (it is always given, event on death)\n    }\n\n    struct Commitment {\n        bytes24 hash;\n        uint32 epoch;\n    }\n\n    // ----------------------------------------------------------------------------------------------\n    // MEMORY ONLY TYPES\n    // ----------------------------------------------------------------------------------------------\n\n    // this only track what changes\n    // when life is zero,\n    // gold and equiipment are considered taken\n    // uint256 gold;\n    // bytes32 equipment;\n\n    struct Monster {\n        uint8 life;\n        uint16 combatStance;\n    }\n\n    struct Action {\n        uint256 position; // TODO uint64\n        bool pickTreasure;\n    }\n\n    struct Room {\n        bool[4] exits;\n        bool treasure;\n        bool monster;\n    }\n\n    // ----------------------------------------------------------------------------------------------\n    // STORAGE\n    // ----------------------------------------------------------------------------------------------\n\n    mapping(uint256 => mapping(uint256 => GoldBattle)) public goldBattles; // we use epoch to ensure not reading from last // TODO optimize by keeping track of epoch used instead of mapping\n    mapping(uint256 => mapping(uint256 => MonsterBattle)) public monsterBattles; // per epoch, so player can claim later: TODO document the 2 and half phase system\n    mapping(uint256 => uint256) public monsterClaims;\n    mapping(uint256 => Character) public characters;\n    mapping(uint256 => address) public owners;\n    mapping(uint256 => Commitment) public commitments;\n\n    bytes32 internal epochHash_0;\n    bytes32 internal epochHash_1;\n\n    // TODO\n    // bytes32 internal layer2_epochHash_0;\n    // bytes32 internal layer2_epochHash_1;\n\n    Characters immutable characterTokens;\n\n    // ----------------------------------------------------------------------------------------------\n    // CONSTRUCTOR / INITIALIZER\n    // ----------------------------------------------------------------------------------------------\n\n    constructor(Characters charactersCollection) {\n        characterTokens = charactersCollection;\n        postUpgrade(charactersCollection);\n    }\n\n    function postUpgrade(Characters charactersCollection) public proxied {\n        if (charactersCollection != characterTokens) {\n            revert(\"characterTokens is immutable\");\n        }\n\n        // TODO with forge-deploy-proxy this is not called\n        (uint32 epoch, bool commiting) = _epoch();\n        // this is the first event, signaling to the indexer the first hash and epoch\n        _handleEpochHash(commiting ? epoch - 1 : epoch, bytes32(0));\n    }\n\n    // ----------------------------------------------------------------------------------------------\n    // PUBLIC INTERFACE\n    // ----------------------------------------------------------------------------------------------\n\n    function enter() external payable {\n        require(msg.value == 1000000000000000, \"GIVE ME THE KWEI\");\n        // for now we just associate character with wallet\n        // TODO\n        // TODO leaving\n        uint256 characterID = uint256(uint160(msg.sender));\n        require(owners[characterID] == address(0), \"ALREADY_IN\");\n        characterTokens.mint(characterID, address(this));\n        owners[characterID] = msg.sender;\n        emit CharacterEnterTheDungeon(msg.sender, characterID);\n\n        _handleCharacter(\n            characterID, Character({position: 0, life: 3, gold: 0, equipment: bytes32(0), combatStanceAvailable: 511})\n        );\n    }\n\n    function makeCommitment(uint256 characterID, bytes24 commitmentHash) external {\n        require(owners[characterID] == msg.sender, \"NOT_OWNER\");\n        Character memory character = characters[characterID];\n        require(character.life > 0, \"DEAD\");\n        _makeCommitment(characterID, commitmentHash);\n    }\n\n    function resolve(\n        uint256 characterID,\n        bytes32 secret,\n        Action[] calldata actions,\n        uint16 combatStance,\n        bytes24 furtherActions\n    ) external {\n        Commitment storage commitment = commitments[characterID];\n        (uint32 epoch, bool commiting) = _epoch();\n\n        require(!commiting, \"IN_COMMITING_PHASE\");\n        require(commitment.epoch != 0, \"NOTHING_TO_RESOLVE\");\n        require(commitment.epoch == epoch, \"INVALID_epoch\");\n\n        _checkHash(commitment.hash, secret, actions, combatStance, furtherActions);\n\n        // we emit that first to signal, any new state is now computed for the new epoch\n        // if we do after other events, then the event will not be first and its last occurence would not be able to indicate the end\n        _handleEpochHash(epoch, secret);\n\n        Character memory character = characters[characterID];\n\n        require(\n            // TODO count the number of bit too\n            combatStance | character.combatStanceAvailable == character.combatStanceAvailable,\n            \"INVALID_COMBAT_STANCE\"\n        );\n\n        character.combatStanceAvailable = character.combatStanceAvailable ^ combatStance;\n\n        Room memory currentRoom = computeRoom(\n            roomHash(epoch, character.position),\n            // TODO layer 2 epoch Hash\n            roomHash(bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), character.position)\n        );\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            Action memory action = actions[i];\n            Room memory newRoom = computeRoom(\n                roomHash(epoch, action.position),\n                // TODO layer 2 epoch Hash\n                roomHash(\n                    bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), character.position\n                )\n            );\n\n            if (_isValidMove(character.position, currentRoom, action.position, newRoom)) {\n                character.position = action.position;\n                currentRoom = newRoom;\n                if (action.pickTreasure) {\n                    if (currentRoom.treasure) {\n                        _handleGoldBattle(epoch, characterID, character, combatStance);\n                    }\n                    // } else if (action.battleMonster) {\n                    //     if (currentRoom.monster) {\n                    //         // Monster monster = room.monster;\n                    //         _handleMonsterBattle(epoch, characterID, character, combatStance);\n                    //     }\n                }\n            } else {\n                // For now:\n                revert(\"invalid move\");\n\n                // we do not continue when we encounter an invalid move\n                // for simplicity, we still count was was computed so far\n                // TODO alternative: revert the whole moves but keep the commitment\n                // break;\n            }\n        }\n\n        _handleCommitment(characterID, epoch, commitment, actions, furtherActions);\n\n        _handleCharacter(characterID, character);\n    }\n\n    function _handleGoldBattle(uint256 epoch, uint256 characterID, Character memory character, uint16 combatStance)\n        internal\n    {\n        GoldBattle memory battle = goldBattles[epoch][character.position];\n        if (battle.combatStance == 0) {\n            character.gold = character.gold + 1 ether;\n            battle.currentWinner = characterID;\n            battle.combatStance = combatStance;\n        } else {\n            // TODO make it commutative\n            // or track but limit the number of character that can get the gold\n            //  in that case, if that limit is reached, nobody is harmed, nobody get the gold\n            int8 result = _battle(combatStance, battle.combatStance);\n            if (result >= 0) {\n                if (battle.currentWinner != 0) {\n                    Character memory previous = characters[battle.currentWinner];\n                    previous.gold = previous.gold - 1 ether;\n                    previous.life = previous.life - 1; // because of order issue, we need to remove that\n                    _handleCharacter(battle.currentWinner, previous);\n                }\n                if (result > 0) {\n                    character.gold = character.gold + 1 ether;\n                    battle.currentWinner = characterID;\n                    battle.combatStance = combatStance;\n                } else {\n                    battle.currentWinner = 0;\n                    battle.combatStance = combatStance; // hmm prder would matter here depending on how they can be equal\n                }\n            } else {\n                character.life = character.life - 1;\n            }\n        }\n\n        goldBattles[epoch][character.position] = battle;\n    }\n\n    function _handleMonsterBattle(\n        uint256 epoch,\n        uint256 characterID,\n        Character memory character,\n        uint16 combatStance,\n        Monster memory monster\n    ) internal {\n        MonsterBattle memory battle = monsterBattles[epoch][character.position];\n        battle.life = battle.life == 0 ? monster.life : battle.life;\n\n        int8 result = _battle(combatStance, monster.combatStance);\n        if (result > 0) {\n            if (battle.life != type(uint256).max) {\n                // if not already dead\n                battle.life--;\n                if (battle.life == 0) {\n                    battle.life = type(uint256).max; // monster is dead\n                    emit MonsterDefeat(character.position, epoch);\n                }\n            }\n        } else if (result < 0) {\n            character.life = character.life - 1;\n        }\n\n        if (battle.life == type(uint256).max) {\n            // no need to fight, you get a share\n            character.gold = character.gold + 2 ether;\n            // NOTE that if we want to make it a share\n            // we can't give gold now, but need to do it in the post-reveal phase (offchain-present, onchain-future)\n        } else {\n            monsterClaims[characterID] = epoch; // the position is the last one, we just need to make sure we execute the claim before anything else\n            emit MonsterClaim(characterID, character.position, epoch);\n        }\n\n        monsterBattles[epoch][character.position] = battle;\n    }\n\n    function _handlePlayerBattle(uint256 epoch, uint256 characterID, Character memory character, uint16 combatStance)\n        internal\n    {\n        // We want to enable player to player battle but to be less harsh we need first some temple room where PVP would be disabled\n        // Currently the only way to attack other player is when they attempt to get the same gold bags as yourself\n    }\n\n    function _battle(uint16 p1_battleStance, uint16 p2_battleStance) internal pure returns (int8 total) {\n        uint8 p1_round = 10;\n        uint8 p2_round = 10;\n        for (uint256 i = 0; i < 3; i++) {\n            p1_round = _getNextValue(p1_battleStance, p1_round - 1);\n            p2_round = _getNextValue(p2_battleStance, p2_round - 1);\n            if (p1_round > p2_round) {\n                total = total + 1;\n            } else if (p1_round < p2_round) {\n                total = total - 1;\n            }\n        }\n    }\n\n    function _getNextValue(uint16 combatStance, uint8 start) internal pure returns (uint8) {\n        for (int256 i = (int8(start) - 1); i >= 0; i--) {\n            if ((combatStance >> uint256(i)) != 0) {\n                return uint8(uint256(i + 1));\n            }\n        }\n        return 0; // invalid\n    }\n\n    function _handleCommitment(\n        uint256 characterID,\n        uint32 epoch,\n        Commitment storage commitment,\n        Action[] memory actions,\n        bytes24 furtherActions\n    ) internal {\n        bytes24 hashResolved = commitment.hash;\n        if (furtherActions != bytes24(0)) {\n            commitment.hash = furtherActions;\n        } else {\n            commitment.epoch = 0; // used\n        }\n\n        emit CommitmentResolved(characterID, epoch, hashResolved, actions, furtherActions);\n    }\n\n    function _handleEpochHash(uint32 epoch, bytes32 secret) internal {\n        // we compute our epochHash as reveal are entered\n        // Note that later we might want to only use commitment who has gone deep enough in the dungeon\n        if (epoch % 2 == 0) {\n            epochHash_1 = secret ^ epochHash_1;\n            emit EpochHashUpdate(epoch + 1, epochHash_1);\n        } else {\n            epochHash_0 = secret ^ epochHash_0;\n            emit EpochHashUpdate(epoch + 1, epochHash_0);\n        }\n    }\n\n    function _handleCharacter(uint256 characterID, Character memory character) internal {\n        characters[characterID] = character;\n\n        // CommitmentResolved event contains everything needed for an indexer to recompute the state\n        // but here for simplicity we emit the latest data just computed\n\n        emit CharacterUpdate(\n            characterID,\n            character.position,\n            character.life,\n            character.gold,\n            character.equipment,\n            character.combatStanceAvailable\n        );\n    }\n\n    function roomID(int32 x, int32 y) public pure returns (uint256) {\n        unchecked {\n            return uint256(uint256(uint64(uint32(y)) << 32) + uint32(x));\n        }\n    }\n\n    function roomCoords(uint256 id) public pure returns (int32 x, int32 y) {\n        unchecked {\n            x = int32(int256(id & 0xFFFFFFFF));\n            y = int32(int256(id >> 32));\n        }\n    }\n\n    function roomHash(uint32 epoch, int32 x, int32 y) public view returns (bytes32) {\n        return roomHash(epoch, roomID(x, y));\n    }\n\n    function roomHash(uint32 epoch, uint256 id) public view returns (bytes32) {\n        bytes32 epochHash = epoch % 2 == 0 ? epochHash_0 : epochHash_1;\n        return roomHash(epochHash, id);\n    }\n\n    function roomHash(bytes32 epochHash, uint256 id) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(epochHash, id));\n    }\n\n    function computeRoom(bytes32 roomHashData, bytes32 roomHashData2) public pure returns (Room memory) {\n        // // take from the first 0 (right side) and take 2 bits to give you a number between [0,2**2[\n        // const firstExit = value(roomHashData, 0, 2);\n        uint8 firstExit = uint8(Extraction.value(roomHashData, 0, 2));\n\n        // const hasSecondExit = value(roomHashData, 2, 5) < 3; // take 32 values [0,2**5[\n        bool hasSecondExit = uint8(Extraction.value(roomHashData, 2, 5)) < 10;\n        // const secondExitRaw = value(roomHashData, 7, 2); // this has one value too much.\n        uint8 secondExitRaw = uint8(Extraction.value(roomHashData, 7, 2));\n        // const secondExit = hasSecondExit && secondExitRaw < 3 ? secondExitRaw : 4;\n        uint8 secondExit = (hasSecondExit && secondExitRaw < 3) ? secondExitRaw : 4;\n        // // const thirdExist = firstExit + ((Math.floor(Math.random() * 3) + 1) % 4);\n        // // const fourthExit = firstExit + ((Math.floor(Math.random() * 3) + 1) % 4);\n\n        // const treasure = value(roomHashData, 9, 10) < 7; // take 1024 values [0,2**10[\n        bool treasure = Extraction.value(roomHashData2, 9, 10) < 20;\n\n        // const monsterRaw = value(roomHashData, 19, 7); // take 128 values [0,2**7[\n        // TODO roomHashData3 ?\n        uint8 monsterRaw = uint8(Extraction.value(roomHashData, 19, 7));\n        // const monster = treasure ? monsterRaw < 30 : monsterRaw < 1;\n        bool monster = treasure ? monsterRaw < 30 : monsterRaw < 1;\n\n        return Room({\n            exits: [\n                firstExit == 0 || secondExit == 0,\n                firstExit == 1 || secondExit == 1,\n                firstExit == 2 || secondExit == 2,\n                firstExit == 3 || secondExit == 3\n            ],\n            treasure: treasure,\n            monster: monster\n        });\n    }\n\n    // ----------------------------------------------------------------------------------------------\n    // INTERNAL\n    // ----------------------------------------------------------------------------------------------\n\n    function _makeCommitment(uint256 characterID, bytes24 commitmentHash) internal {\n        Commitment storage commitment = commitments[characterID];\n\n        (uint32 epoch, bool commiting) = _epoch();\n\n        console.log(\"epoch\");\n        console.logUint(epoch);\n\n        // TODO extract this into a separate function that can also be called by anyone (past the corresponding reveal phase)\n        //  Would be used to claim the gold, equipment, etc...\n        if (commitment.epoch != 0 && commitment.epoch != epoch) {\n            characters[characterID].life = 0;\n            commitment.epoch = 0;\n\n            emit CommitmentVoid(characterID, epoch);\n\n            // CommitmentVoid event contains everything needed for an indexer to recompute the state\n            // but here for simplicity we emit the latest data just computed\n            emit CharacterUpdate(\n                characterID,\n                characters[characterID].position,\n                characters[characterID].life,\n                characters[characterID].gold,\n                characters[characterID].equipment,\n                0\n            );\n        }\n\n        require(commiting, \"IN_RESOLUTION_PHASE\");\n        require(commitment.epoch == 0 || commitment.epoch == epoch, \"PREVIOUS_COMMITMENT_TO_RESOLVE\");\n\n        commitment.hash = commitmentHash;\n        commitment.epoch = epoch;\n\n        // Note: A character can change its commitment at any time until the commit phase ends.\n        emit CommitmentMade(characterID, epoch, commitmentHash);\n    }\n\n    function _checkHash(\n        bytes24 commitmentHash,\n        bytes32 secret,\n        Action[] memory actions,\n        uint16 combatStance,\n        bytes24 furtherActions\n    ) internal pure {\n        if (furtherActions != bytes24(0)) {\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, actions, combatStance, furtherActions)));\n            require(commitmentHash == computedHash, \"HASH_NOT_MATCHING\");\n        } else {\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, actions, combatStance)));\n            require(commitmentHash == computedHash, \"HASH_NOT_MATCHING\");\n        }\n    }\n\n    function _epoch() internal view virtual returns (uint32 epoch, bool commiting) {\n        uint256 epochDuration = TOTAL;\n\n        // For now START_TIMESTAMP = 0\n        require(_timestamp() >= START_TIMESTAMP, \"GAME_NOT_STARTED\");\n\n        uint256 timePassed = _timestamp() - START_TIMESTAMP;\n        epoch = uint32((timePassed / epochDuration) + 1);\n        commiting = timePassed - ((epoch - 1) * epochDuration) < ACTION_PERIOD;\n    }\n\n    function _isValidMove(uint256 roomPosition, Room memory room, uint256 newPosition, Room memory newRoom)\n        internal\n        view // pure\n        returns (bool)\n    {\n        (int32 x, int32 y) = roomCoords(roomPosition);\n        (int32 nx, int32 ny) = roomCoords(newPosition);\n        if (x == nx && y == ny) {\n            console.log(\"same\");\n            return true;\n        }\n        uint8 direction = _direction(x, y, nx, ny);\n        if (direction == 4) {\n            return false;\n        }\n        return room.exits[direction] || newRoom.exits[(direction + 2) % 4];\n    }\n\n    function _direction(int32 fromx, int32 fromy, int32 tox, int32 toy) internal pure returns (uint8) {\n        int64 x_diff = int64(tox) - fromx;\n        int64 y_diff = int64(toy) - fromy;\n        if (x_diff == 0) {\n            if (y_diff == 1) {\n                return 2;\n            } else if (y_diff == -1) {\n                return 0;\n            } else {\n                return 4; // undefined\n            }\n        } else {\n            if (x_diff == 1) {\n                return 1;\n            } else if (x_diff == -1) {\n                return 3;\n            } else {\n                return 4; // undefined\n            }\n        }\n    }\n\n    function _timestamp() internal view virtual override returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "src/Extraction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nlibrary Extraction {\n    function value(bytes32 data, uint8 leastSignificantBit, uint8 size) internal pure returns (uint256) {\n        return uint256((data >> leastSignificantBit)) % 2 ** size;\n    }\n}\n"
    },
    "src/TimeControlledDungeon.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./Dungeon.sol\";\nimport \"./Characters.sol\";\nimport \"./UsingControlledTime.sol\";\n\ncontract TimeControlledDungeon is Dungeon, UsingControlledTime {\n    constructor(Characters characters) Dungeon(characters) {}\n\n    // TODO could we move that into UsingControlledTime\n    function _timestamp() internal view virtual override(Dungeon, UsingInternalTimestamp) returns (uint256) {\n        return block.timestamp + _delta();\n    }\n}\n"
    },
    "src/UsingControlledTime.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./UsingInternalTimestamp.sol\";\n\nabstract contract UsingControlledTime is UsingInternalTimestamp {\n    event TimeIncreased(uint256 newTime, uint256 delta);\n\n    function timestamp() external view returns (uint256) {\n        return _timestamp();\n    }\n\n    function increaseTime(uint256 delta) external {\n        address adminAddress;\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n        require(msg.sender == adminAddress, \"NOT_ADMIN\");\n        uint256 newDelta = _delta() + delta;\n        assembly {\n            sstore(0x112c413de07a110ce0a9ace0c01e41b5b59462770325b042f0dc72c337f55f2, newDelta)\n        }\n        emit TimeIncreased(_timestamp(), delta);\n    }\n\n    function _delta() internal view returns (uint256 delta) {\n        assembly {\n            // keccak256(\"time\") - 1\n            delta := sload(0x112c413de07a110ce0a9ace0c01e41b5b59462770325b042f0dc72c337f55f2)\n        }\n    }\n}\n"
    },
    "src/UsingInternalTimestamp.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nabstract contract UsingInternalTimestamp {\n    function _timestamp() internal view virtual returns (uint256);\n}\n"
    },
    "src/Vessels.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.20;\n\nimport \"solidity-kit/solc_0.8/ERC721/implementations/BasicERC721.sol\";\n\nabstract contract Vessels is BasicERC721 {\n    // ----------------------------------------------------------------------------------------------\n    // EVENTS\n    // ----------------------------------------------------------------------------------------------\n    event VesselSlotUpdate(uint256 indexed id, address indexed namespace, uint256 indexed slot, bytes32 slotData);\n    event VesselDataUpdate(uint256 indexed id, address indexed namespace, bytes data);\n\n    // ----------------------------------------------------------------------------------------------\n    // STORAGE\n    // ----------------------------------------------------------------------------------------------\n    mapping(uint256 => mapping(address => mapping(uint256 => bytes32))) _slots;\n    mapping(uint256 => mapping(address => bytes)) _data;\n\n    // ----------------------------------------------------------------------------------------------\n    // PUBLIC INTERFACE\n    // ----------------------------------------------------------------------------------------------\n\n    /// @notice return the character's slot data for the caller's namespace\n    function getSlot(uint256 id, uint256 index) external view returns (bytes32) {\n        return _slots[id][msg.sender][index];\n    }\n\n    /// @notice return the character's slot data for the provided namespace\n    function getSlotFor(uint256 id, address namespace, uint256 index) external view returns (bytes32) {\n        return _slots[id][namespace][index];\n    }\n\n    /// @notice set the character's slot data on the caller's namespace\n    function setSlot(uint256 id, uint256 index, bytes32 slotData) external {\n        _setSlotFor(id, msg.sender, index, slotData);\n    }\n\n    // /// @notice set the character's slot data on the provided namespace\n    // function setSlot(uint256 id, address namespace, uint256 index, bytes32 slotData) external {\n    //     revert(\"NOT_IMPLEMENTED\");\n    //     // TODO allow delegation for other contract to setData on some other contract\n    //     // require(msg.sender == );\n    //     // _setSlotFor(id, msg.sender, index, slotData);\n    // }\n\n    /// @notice return the character's data for the caller's namespace\n    function getData(uint256 id) external view returns (bytes memory) {\n        return _data[id][msg.sender];\n    }\n\n    /// @notice return the character's data for the provided namespace\n    function getDataFor(uint256 id, address namespace) external view returns (bytes memory) {\n        return _data[id][namespace];\n    }\n\n    /// @notice set the character's data on the caller's namespace\n    function setData(uint256 id, bytes calldata data) external {\n        _setDataFor(id, msg.sender, data);\n    }\n\n    // /// @notice set the character's data on the provided namespace\n    // function setData(uint256 id, address namespace, bytes calldata data) external {\n    //     revert(\"NOT_IMPLEMENTED\");\n    //     // TODO allow delegation for other contract to setData on some other contract\n    //     // require(msg.sender == );\n    //     // _setDataFor(id, msg.sender, index, slotData);\n    // }\n\n    // ----------------------------------------------------------------------------------------------\n    // INTERNAL\n    // ----------------------------------------------------------------------------------------------\n    function _setSlotFor(uint256 id, address namespace, uint256 index, bytes32 slotData) internal {\n        _slots[id][namespace][index] = slotData;\n        emit VesselSlotUpdate(id, namespace, index, slotData);\n    }\n\n    function _setDataFor(uint256 id, address namespace, bytes memory data) internal {\n        _data[id][namespace] = data;\n        emit VesselDataUpdate(id, namespace, data);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363834383631383336373237"
      }
    }
  }
}